\relax 
\@writefile{toc}{\contentsline {section}{\numberline {1}Exercise 1. Familiarize yourself with the assembly language materials available on the 6.828 reference page. We do recommend reading the section "The Syntax" in Brennan's Guide to Inline Assembly.}{1}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Exercise 2. Use GDB's si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing.}{1}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Exercise 3.}{1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}Take a look at the lab tools guide, especially the section on GDB commands.}{1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2}Set a breakpoint at address 0x7c00, which is where the boot sector will be loaded. Continue execution until that breakpoint. Trace through the code in boot/boot.S, using the source code and the disassembly file obj/boot/boot.asm to keep track of where you are. Also use the x/i command in GDB to disassemble sequences of instructions in the boot loader, and compare the original boot loader source code with both the disassembly in obj/boot/boot.asm and GDB.}{1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.3}Trace into bootmain() in boot/main.c, and then into readsect(). Identify the exact assembly instructions that correspond to each of the statements in readsect(). Trace through the rest of readsect() and back out into bootmain(), and identify the begin and end of the for loop that reads the remaining sectors of the kernel from the disk. Find out what code will run when the loop is finished, set a breakpoint there, and continue to that breakpoint. Then step through the remainder of the boot loader.}{1}}
\@writefile{toc}{\contentsline {section}{\numberline {4}Exercise 4. Read about programming with pointers in C.}{2}}
\@writefile{toc}{\contentsline {section}{\numberline {5}Exercise 5.Trace through the first few instructions of the boot loader again and identify the first instruction that would "break" or otherwise do the wrong thing if you were to get the boot loader's link address wrong. Then change the link address in boot/Makefrag to something wrong, run make clean, recompile the lab with make, and trace into the boot loader again to see what happens.}{2}}
\@writefile{toc}{\contentsline {section}{\numberline {6}Exercise 6. Reset the machine. Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.) }{2}}
\@writefile{toc}{\contentsline {section}{\numberline {7}Exercise 7.}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.1}Use QEMU and GDB to trace into the JOS kernel and stop at the movl \% eax,\% cr0.Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000.}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.2}What is the first instruction after the new mapping is established that would fail to work properly if the mapping weren't in place? Comment out the movl \% eax, \% cr0 in kern$/$entry.S, trace into it, and see if you were right.}{2}}
\@writefile{toc}{\contentsline {section}{\numberline {8}Exercise 8. The code necessary to print octal numbers using patterns of the form \emph  {\%o}. Find and fill in this code fragment.}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {8.1}Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c? }{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {8.2}Explain the following from console.c:}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {8.3} Trace the execution of the following code step-by-step}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {8.4}Run the following code.}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {8.5}In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen? }{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {8.6}Let's say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change cprintf or its interface so that it would still be possible to pass it a variable number of arguments?}{3}}
\@writefile{toc}{\contentsline {section}{\numberline {9}Exercise 9. Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which "end" of this reserved area is the stack pointer initialized to point to?}{3}}
\@writefile{toc}{\contentsline {section}{\numberline {10}Exercise 10. To become familiar with the C calling conventions on the x86, find the address of the test$\_$backtrace function in obj/kern/kernel.asm, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32$-$bit words does each recursive nesting level of test$\_$backtrace push on the stack, and what are those words?}{3}}
\@writefile{toc}{\contentsline {section}{\numberline {11}Exercise 11. Implement the backtrace function as specified above}{4}}
\@writefile{toc}{\contentsline {section}{\numberline {12}Exercise 12.}{4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {12.1}Modify your stack backtrace function to display, for each eip, the function name, source file name, and line number corresponding to that eip.}{4}}
